import {
  __commonJS,
  __publicField
} from "./chunk-TCQZMY3T.js";

// node_modules/node-json-db/dist/lib/Utils.js
var require_Utils = __commonJS({
  "node_modules/node-json-db/dist/lib/Utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.removeTrailingChar = exports.merge = void 0;
    var merge = (...arrays) => {
      const destination = {};
      arrays.forEach(function(source) {
        var prop;
        for (prop in source) {
          if (prop in destination && destination[prop] === null) {
            destination[prop] = source[prop];
          } else if (prop in destination && Array.isArray(destination[prop])) {
            destination[prop] = destination[prop].concat(source[prop]);
          } else if (prop in destination && typeof destination[prop] === "object") {
            destination[prop] = (0, exports.merge)(destination[prop], source[prop]);
          } else {
            destination[prop] = source[prop];
          }
        }
      });
      return destination;
    };
    exports.merge = merge;
    var removeTrailingChar = (dataPath, trailing) => {
      if (dataPath.length > 1 && dataPath.endsWith(trailing)) {
        return dataPath.substring(0, dataPath.length - 1);
      }
      return dataPath;
    };
    exports.removeTrailingChar = removeTrailingChar;
  }
});

// node_modules/node-json-db/dist/lib/Errors.js
var require_Errors = __commonJS({
  "node_modules/node-json-db/dist/lib/Errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataError = exports.DatabaseError = exports.NestedError = void 0;
    var NestedError = class extends Error {
      constructor(message, id, inner) {
        super(message);
        __publicField(this, "inner");
        __publicField(this, "id");
        this.inner = inner;
        this.id = id;
        this.name = this.constructor.name;
      }
      toString() {
        const string = this.name + ": " + this.message;
        if (this.inner) {
          return string + ":\n" + this.inner;
        }
        return string;
      }
    };
    exports.NestedError = NestedError;
    var DatabaseError = class extends NestedError {
    };
    exports.DatabaseError = DatabaseError;
    var DataError = class extends NestedError {
    };
    exports.DataError = DataError;
  }
});

// node_modules/node-json-db/dist/lib/ArrayInfo.js
var require_ArrayInfo = __commonJS({
  "node_modules/node-json-db/dist/lib/ArrayInfo.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getArrayIndicies = exports.validateArrayIndex = exports.validateArrayIndicies = exports.isInt = exports.ArrayInfo = exports.arrayRegex = void 0;
    var Errors_1 = require_Errors();
    var arrayRegex = () => /^([\.0-9a-zA-Z_$\-][0-9a-zA-Z_\-$\.]*)\[((?!(\]|\[)).*|)\]$/gm;
    exports.arrayRegex = arrayRegex;
    var regexCache = {};
    var ArrayInfo = class _ArrayInfo {
      constructor(property, indicies) {
        __publicField(this, "property");
        __publicField(this, "index", 0);
        __publicField(this, "append", false);
        __publicField(this, "indicies", []);
        this.property = property;
        const index = indicies[0] ?? 0;
        this.append = index === "" || indicies[indicies.length - 1] === "";
        this.indicies = indicies;
        if (isInt(index)) {
          this.index = parseInt(index);
        } else if (!this.append) {
          throw new Errors_1.DataError("Only numerical values accepted for array index", 200);
        }
      }
      /**
       * Check if the property want to access an Array
       * @param property
       */
      static processArray(property) {
        if (typeof property === "undefined") {
          return null;
        }
        if (regexCache[property]) {
          return regexCache[property];
        }
        const arrayIndexRegex = (0, exports.arrayRegex)();
        const match = arrayIndexRegex.exec(property.trim());
        if (match != null) {
          const propertyName = match[1];
          const nestedArrayMatches = "[" + match[2].toString() + "]";
          const nestedArrayIndicies = getArrayIndicies(nestedArrayMatches);
          validateArrayIndicies(nestedArrayIndicies);
          return regexCache[property] = new _ArrayInfo(propertyName, nestedArrayIndicies);
        }
        return null;
      }
      /**
       * Get the index for the array
       * @param data
       * @param avoidProperty
       */
      getIndex(data, avoidProperty) {
        if (this.append) {
          return -1;
        }
        const index = this.index;
        if (index == -1) {
          const dataIterable = avoidProperty ? data : data[this.property];
          if (dataIterable.length === 0) {
            return 0;
          }
          return dataIterable.length - 1;
        }
        return index;
      }
      /**
       * Get the Data
       * @param data
       */
      getData(data) {
        if (this.append) {
          throw new Errors_1.DataError("Can't get data when appending", 100);
        }
        const { index, dataForProperty } = this.getArrayDataAndIndexFromProperty(data);
        return dataForProperty[index];
      }
      /**
       * Set the data for the array
       * @param data
       * @param value
       */
      setData(data, value) {
        if (this.append) {
          let dataLocationToAppendTo = data[this.property];
          this.indicies.forEach((index) => {
            if (index === "") {
              return;
            }
            index = +index;
            if (index === -1) {
              index = dataLocationToAppendTo.length - 1;
            }
            dataLocationToAppendTo = dataLocationToAppendTo[+index];
          });
          dataLocationToAppendTo.push(value);
        } else {
          const { index, dataForProperty } = this.getArrayDataAndIndexFromProperty(data);
          if (index === -1) {
            dataForProperty.push(value);
          } else {
            dataForProperty[index] = value;
          }
        }
      }
      /**
       * Delete the index from the array
       * @param data
       */
      delete(data) {
        if (this.append) {
          throw new Errors_1.DataError("Can't delete an appended data", 10);
        }
        const { index, dataForProperty } = this.getArrayDataAndIndexFromProperty(data);
        dataForProperty.splice(index, 1);
      }
      /**
       * Check if the ArrayInfo is valid for the given data
       * @param data
       */
      isValid(data) {
        const { index, dataForProperty } = this.getArrayDataAndIndexFromProperty(data);
        return dataForProperty.hasOwnProperty(index);
      }
      getArrayDataAndIndexFromProperty(data) {
        let indexToPull = 0;
        let tempData = data instanceof Array ? data : data[this.property] ?? data;
        if (this.indicies.length > 0) {
          indexToPull = +this.indicies[this.indicies.length - 1];
          for (let i = 0; i < this.indicies.length - 1; i++) {
            let index = +this.indicies[i];
            if (index === -1) {
              index = tempData.length - 1;
            }
            tempData = tempData[index];
          }
          if (indexToPull === -1) {
            indexToPull = tempData.length - 1;
          }
        }
        return { index: indexToPull, dataForProperty: tempData };
      }
      isMultiDimensional() {
        return this.indicies.length > 1;
      }
    };
    exports.ArrayInfo = ArrayInfo;
    function isInt(value) {
      return !isNaN(value) && Number(value) == value && !isNaN(parseInt(value, 10));
    }
    exports.isInt = isInt;
    function validateArrayIndicies(arrayIndicies) {
      const appendIndicies = arrayIndicies.filter((x) => x === "");
      if (appendIndicies.length > 1) {
        throw Error("Only one append index is supported for nested arrays");
      } else if (appendIndicies.length === 1 && arrayIndicies[arrayIndicies.length - 1] !== "") {
        throw Error("Append index must be at the end of the nested array");
      }
    }
    exports.validateArrayIndicies = validateArrayIndicies;
    function validateArrayIndex(index) {
      if (index.length === 0) {
        return;
      }
      if (!isInt(index)) {
        throw new Errors_1.DataError("Only numerical values accepted for array index", 200);
      }
    }
    exports.validateArrayIndex = validateArrayIndex;
    function getArrayIndicies(arrayIndicies) {
      if (arrayIndicies.length === 0) {
        return [];
      }
      if (arrayIndicies.charAt(0) !== "[") {
        throw new Error("Invalid array syntax detected");
      }
      const indexValue = arrayIndicies.substring(1, arrayIndicies.indexOf("]"));
      validateArrayIndex(indexValue);
      const nextArrayIndex = indexValue.length + 2;
      return [
        indexValue,
        ...getArrayIndicies(arrayIndicies.substring(nextArrayIndex))
      ];
    }
    exports.getArrayIndicies = getArrayIndicies;
  }
});

// node_modules/node-json-db/dist/lib/DBParentData.js
var require_DBParentData = __commonJS({
  "node_modules/node-json-db/dist/lib/DBParentData.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DBParentData = void 0;
    var ArrayInfo_1 = require_ArrayInfo();
    var Errors_1 = require_Errors();
    var DBParentData = class {
      constructor(data, db, dataPath, parent) {
        __publicField(this, "parent");
        __publicField(this, "data");
        __publicField(this, "db");
        __publicField(this, "dataPath");
        this.parent = parent;
        this.data = data;
        this.db = db;
        this.dataPath = dataPath;
      }
      /**
       * Check if it's an array
       * @param deletion
       */
      checkArray(deletion = false) {
        const arrayInfo = ArrayInfo_1.ArrayInfo.processArray(this.parent);
        if (arrayInfo && (!arrayInfo.append || deletion) && !arrayInfo.isValid(this.data)) {
          throw new Errors_1.DataError("DataPath: /" + this.dataPath + ". Can't find index " + arrayInfo.index + " in array " + arrayInfo.property, 10);
        }
        return arrayInfo;
      }
      /**
       * Get the data linked to this path
       */
      getData() {
        if (this.parent === void 0) {
          return this.data;
        }
        const arrayInfo = this.checkArray();
        if (arrayInfo) {
          return arrayInfo.getData(this.data);
        } else {
          return this.data[this.parent];
        }
      }
      /**
       * Set the data to the wanted path
       * @param toSet
       */
      setData(toSet) {
        if (this.parent === void 0) {
          this.db.resetData(toSet);
          return;
        }
        const arrayInfo = ArrayInfo_1.ArrayInfo.processArray(this.parent);
        if (arrayInfo) {
          if (!this.data.hasOwnProperty(arrayInfo.property)) {
            this.data[arrayInfo.property] = [];
          } else if (!Array.isArray(this.data[arrayInfo.property])) {
            throw new Errors_1.DataError("DataPath: /" + this.dataPath + ". " + arrayInfo.property + " is not an array.", 11);
          }
          arrayInfo.setData(this.data, toSet);
        } else {
          this.data[this.parent] = toSet;
        }
      }
      /**
       * Delete the data of the current path
       */
      delete() {
        if (this.parent === void 0) {
          this.db.resetData({});
          return;
        }
        const arrayInfo = this.checkArray(true);
        if (arrayInfo) {
          arrayInfo.delete(this.data);
        } else {
          delete this.data[this.parent];
        }
      }
    };
    exports.DBParentData = DBParentData;
  }
});

// node_modules/rwlock/lib/lock.js
var require_lock = __commonJS({
  "node_modules/rwlock/lib/lock.js"(exports, module) {
    module.exports = function() {
      "use strict";
      function a() {
        this.readers = 0, this.queue = [];
      }
      function b(b2, c2, f) {
        var g;
        "function" != typeof b2 ? (e.hasOwnProperty(b2) || (e[b2] = new a()), g = e[b2]) : (f = c2, c2 = b2, g = d), f || (f = {});
        var h = null;
        f.hasOwnProperty("scope") && (h = f.scope);
        var i = function() {
          var a2 = false;
          return function() {
            a2 || (a2 = true, g.readers--, g.queue.length && g.queue[0]());
          };
        }();
        if (g.readers < 0 || g.queue.length) {
          var j = false;
          if (g.queue.push(function() {
            !j && g.readers >= 0 && (j = true, g.queue.shift(), g.readers++, c2.call(h, i), g.queue.length && g.queue[0]());
          }), f.hasOwnProperty("timeout")) {
            var k = null;
            f.hasOwnProperty("timeoutCallback") && (k = f.timeoutCallback), setTimeout(function() {
              j || (j = true, g.queue.shift(), k && k.call(f.scope));
            }, f.timeout);
          }
        } else
          g.readers++, c2.call(f.scope, i);
      }
      function c(b2, c2, f) {
        var g;
        "function" != typeof b2 ? (e.hasOwnProperty(b2) || (e[b2] = new a()), g = e[b2]) : (f = c2, c2 = b2, g = d), f || (f = {});
        var h = null;
        f.hasOwnProperty("scope") && (h = f.scope);
        var i = function() {
          var a2 = false;
          return function() {
            a2 || (a2 = true, g.readers = 0, g.queue.length && g.queue[0]());
          };
        }();
        if (g.readers || g.queue.length) {
          var j = false;
          if (g.queue.push(function() {
            j || g.readers || (j = true, g.queue.shift(), g.readers = -1, c2.call(f.scope, i));
          }), f.hasOwnProperty("timeout")) {
            var k = null;
            f.hasOwnProperty("timeoutCallback") && (k = f.timeoutCallback), setTimeout(function() {
              j || (j = true, g.queue.shift(), k && k.call(h));
            }, f.timeout);
          }
        } else
          g.readers = -1, c2.call(f.scope, i);
      }
      var d = new a(), e = {};
      this.readLock = b, this.writeLock = c, this.async = { readLock: function(a2, c2, d2) {
        "function" != typeof a2 ? b(a2, function(a3) {
          c2.call(this, null, a3);
        }, d2) : (c2 = a2, d2 = c2, b(function(a3) {
          c2.call(this, null, a3);
        }, d2));
      }, writeLock: function(a2, b2, d2) {
        "function" != typeof a2 ? c(a2, function(a3) {
          b2.call(this, null, a3);
        }, d2) : (b2 = a2, d2 = b2, c(function(a3) {
          b2.call(this, null, a3);
        }, d2));
      } };
    };
  }
});

// node_modules/node-json-db/dist/lock/Error.js
var require_Error = __commonJS({
  "node_modules/node-json-db/dist/lock/Error.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TimeoutError = void 0;
    var Errors_1 = require_Errors();
    var TimeoutError = class extends Errors_1.NestedError {
    };
    exports.TimeoutError = TimeoutError;
  }
});

// node_modules/node-json-db/dist/lock/Lock.js
var require_Lock = __commonJS({
  "node_modules/node-json-db/dist/lock/Lock.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.writeLockAsync = exports.readLockAsync = void 0;
    var ReadWriteLock = require_lock();
    var Error_1 = require_Error();
    var lock = new ReadWriteLock();
    var readLockAsync = (func, timeout = null) => {
      let options = {};
      if (timeout != null) {
        options = { timeout };
      }
      return new Promise((resolve, reject) => {
        lock.readLock(async (release) => {
          try {
            const result = await func();
            resolve(result);
          } catch (e) {
            reject(e);
          } finally {
            release();
          }
        }, {
          ...options,
          timeoutCallback() {
            reject(new Error_1.TimeoutError("Timeout", 100));
          }
        });
      });
    };
    exports.readLockAsync = readLockAsync;
    var writeLockAsync = (func, timeout = null) => {
      let options = {};
      if (timeout != null) {
        options = { timeout };
      }
      return new Promise((resolve, reject) => {
        lock.writeLock(async (release) => {
          try {
            const result = await func();
            resolve(result);
          } catch (e) {
            reject(e);
          } finally {
            release();
          }
        }, {
          ...options,
          timeoutCallback() {
            reject(new Error_1.TimeoutError("Timeout", 100));
          }
        });
      });
    };
    exports.writeLockAsync = writeLockAsync;
  }
});

// browser-external:path
var require_path = __commonJS({
  "browser-external:path"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "path" has been externalized for browser compatibility. Cannot access "path.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-json-db/dist/adapter/data/JsonAdapter.js
var require_JsonAdapter = __commonJS({
  "node_modules/node-json-db/dist/adapter/data/JsonAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonAdapter = void 0;
    var JsonAdapter = class {
      constructor(adapter, humanReadable = false) {
        __publicField(this, "adapter");
        __publicField(this, "humanReadable");
        __publicField(this, "dateRegex", new RegExp("^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}", "m"));
        this.adapter = adapter;
        this.humanReadable = humanReadable;
      }
      replacer(key, value) {
        return value;
      }
      reviver(key, value) {
        if (typeof value == "string" && this.dateRegex.exec(value) != null) {
          return new Date(value);
        }
        return value;
      }
      async readAsync() {
        const data = await this.adapter.readAsync();
        if (data == null) {
          await this.writeAsync({});
          return {};
        }
        return JSON.parse(data, this.reviver.bind(this));
      }
      writeAsync(data) {
        let stringify = "";
        if (this.humanReadable) {
          stringify = JSON.stringify(data, this.replacer.bind(this), 4);
        } else {
          stringify = JSON.stringify(data, this.replacer.bind(this));
        }
        return this.adapter.writeAsync(stringify);
      }
    };
    exports.JsonAdapter = JsonAdapter;
  }
});

// browser-external:fs/promises
var require_promises = __commonJS({
  "browser-external:fs/promises"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "fs/promises" has been externalized for browser compatibility. Cannot access "fs/promises.${key}" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/node-json-db/dist/adapter/file/FileAdapter.js
var require_FileAdapter = __commonJS({
  "node_modules/node-json-db/dist/adapter/file/FileAdapter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FileAdapter = void 0;
    var promises_1 = require_promises();
    var path = require_path();
    var FileAdapter = class {
      constructor(filename, fsync) {
        __publicField(this, "filename");
        __publicField(this, "fsync");
        this.filename = filename;
        this.fsync = fsync;
      }
      async readAsync() {
        try {
          return await (0, promises_1.readFile)(this.filename, {
            encoding: "utf-8"
          });
        } catch (e) {
          if (e.code === "ENOENT") {
            return null;
          }
          throw e;
        }
      }
      async writeAsync(data) {
        let fd = null;
        try {
          fd = await (0, promises_1.open)(this.filename, "w");
        } catch (e) {
          if (e.code !== "ENOENT") {
            throw e;
          }
          const basepath = path.dirname(this.filename);
          await (0, promises_1.mkdir)(basepath, { recursive: true });
          fd = await (0, promises_1.open)(this.filename, "w");
        }
        try {
          await fd.writeFile(data, {
            encoding: "utf-8"
          });
          if (this.fsync) {
            await fd.sync();
          }
        } finally {
          await fd.close();
        }
      }
    };
    exports.FileAdapter = FileAdapter;
  }
});

// node_modules/node-json-db/dist/lib/JsonDBConfig.js
var require_JsonDBConfig = __commonJS({
  "node_modules/node-json-db/dist/lib/JsonDBConfig.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ConfigWithAdapter = exports.Config = void 0;
    var path = require_path();
    var JsonAdapter_1 = require_JsonAdapter();
    var FileAdapter_1 = require_FileAdapter();
    var Config = class {
      constructor(filename, saveOnPush = true, humanReadable = false, separator = "/", syncOnSave = false) {
        __publicField(this, "adapter");
        __publicField(this, "filename");
        __publicField(this, "saveOnPush");
        __publicField(this, "separator");
        this.filename = filename;
        if (path.extname(filename) === "") {
          this.filename += ".json";
        }
        this.saveOnPush = saveOnPush;
        this.separator = separator;
        this.adapter = new JsonAdapter_1.JsonAdapter(new FileAdapter_1.FileAdapter(this.filename, syncOnSave), humanReadable);
      }
    };
    exports.Config = Config;
    var ConfigWithAdapter = class {
      constructor(adapter, saveOnPush = true, separator = "/") {
        __publicField(this, "adapter");
        __publicField(this, "saveOnPush");
        __publicField(this, "separator");
        this.adapter = adapter;
        this.saveOnPush = saveOnPush;
        this.separator = separator;
      }
    };
    exports.ConfigWithAdapter = ConfigWithAdapter;
  }
});

// node_modules/node-json-db/dist/JsonDB.js
var require_JsonDB = __commonJS({
  "node_modules/node-json-db/dist/JsonDB.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonDB = exports.FileAdapter = exports.JsonAdapter = exports.DataError = exports.DatabaseError = exports.ConfigWithAdapter = exports.Config = void 0;
    var Utils_1 = require_Utils();
    var Errors_1 = require_Errors();
    var DBParentData_1 = require_DBParentData();
    var ArrayInfo_1 = require_ArrayInfo();
    var Lock_1 = require_Lock();
    var JsonDBConfig_1 = require_JsonDBConfig();
    Object.defineProperty(exports, "Config", { enumerable: true, get: function() {
      return JsonDBConfig_1.Config;
    } });
    Object.defineProperty(exports, "ConfigWithAdapter", { enumerable: true, get: function() {
      return JsonDBConfig_1.ConfigWithAdapter;
    } });
    var Errors_2 = require_Errors();
    Object.defineProperty(exports, "DatabaseError", { enumerable: true, get: function() {
      return Errors_2.DatabaseError;
    } });
    Object.defineProperty(exports, "DataError", { enumerable: true, get: function() {
      return Errors_2.DataError;
    } });
    var JsonAdapter_1 = require_JsonAdapter();
    Object.defineProperty(exports, "JsonAdapter", { enumerable: true, get: function() {
      return JsonAdapter_1.JsonAdapter;
    } });
    var FileAdapter_1 = require_FileAdapter();
    Object.defineProperty(exports, "FileAdapter", { enumerable: true, get: function() {
      return FileAdapter_1.FileAdapter;
    } });
    var JsonDB = class {
      /**
       * JSONDB Constructor
       * @param config Configuration for the database
       */
      constructor(config) {
        __publicField(this, "loaded", false);
        __publicField(this, "data", {});
        __publicField(this, "config");
        this.config = config;
      }
      /**
       * Process datapath into different parts
       * @param dataPath
       */
      processDataPath(dataPath) {
        if (dataPath === void 0 || !dataPath.trim()) {
          throw new Errors_1.DataError("The Data Path can't be empty", 6);
        }
        if (dataPath == this.config.separator) {
          return [];
        }
        dataPath = (0, Utils_1.removeTrailingChar)(dataPath, this.config.separator);
        const path = dataPath.split(this.config.separator);
        path.shift();
        return path;
      }
      async retrieveData(dataPath, create = false) {
        await this.load();
        const thisDb = this;
        const recursiveProcessDataPath = (data, index) => {
          let property = dataPath[index];
          function findData(isArray = false) {
            if (data.hasOwnProperty(property)) {
              data = data[property];
            } else if (create) {
              if (isArray) {
                data[property] = [];
              } else {
                data[property] = {};
              }
              data = data[property];
            } else {
              throw new Errors_1.DataError(`Can't find dataPath: ${thisDb.config.separator}${dataPath.join(thisDb.config.separator)}. Stopped at ${property}`, 5);
            }
          }
          const arrayInfo = ArrayInfo_1.ArrayInfo.processArray(property);
          if (arrayInfo) {
            property = arrayInfo.property;
            findData(true);
            if (!Array.isArray(data)) {
              throw new Errors_1.DataError(`DataPath: ${thisDb.config.separator}${dataPath.join(thisDb.config.separator)}. ${property} is not an array.`, 11);
            }
            const arrayIndex = arrayInfo.getIndex(data, true);
            if (!arrayInfo.append && data.hasOwnProperty(arrayIndex)) {
              data = arrayInfo.getData(data);
            } else if (create) {
              if (arrayInfo.append) {
                data.push({});
                data = data[data.length - 1];
              } else {
                data[arrayIndex] = {};
                data = data[arrayIndex];
              }
            } else {
              throw new Errors_1.DataError(`DataPath: ${thisDb.config.separator}${dataPath.join(thisDb.config.separator)}. . Can't find index ${arrayInfo.index} in array ${property}`, 10);
            }
          } else {
            findData();
          }
          if (dataPath.length == ++index) {
            return data;
          }
          return recursiveProcessDataPath(data, index);
        };
        if (dataPath.length === 0) {
          return this.data;
        }
        return recursiveProcessDataPath(this.data, 0);
      }
      async getParentData(dataPath, create) {
        const path = this.processDataPath(dataPath);
        const last = path.pop();
        return new DBParentData_1.DBParentData(await this.retrieveData(path, create), this, dataPath, last);
      }
      /**
       * Get the wanted data
       * @param dataPath path of the data to retrieve
       * @returns {Promise<any>}
       */
      getData(dataPath) {
        return (0, Lock_1.readLockAsync)(async () => {
          const path = this.processDataPath(dataPath);
          return this.retrieveData(path, false);
        });
      }
      /**
       * Same as getData only here it's directly typed to your object
       * @param dataPath  path of the data to retrieve
       * @returns {Promise}
       */
      getObject(dataPath) {
        return this.getData(dataPath);
      }
      /**
       * Same as getData but with your own object type and a possible default value when we can't find the data path
       * @param dataPath path of the data to retrieve
       * @param defaultValue value to use when the dataPath doesn't lead to data
       * @returns {Promise}
       * @throws {DataError}
       */
      async getObjectDefault(dataPath, defaultValue) {
        try {
          return await this.getData(dataPath);
        } catch (e) {
          if (!(e instanceof Errors_1.DataError)) {
            throw e;
          }
          if (e.id != 5) {
            throw e;
          }
          return defaultValue;
        }
      }
      /**
       * Check for existing datapath
       * @param dataPath
       * @returns {Promise<boolean>}
       */
      async exists(dataPath) {
        try {
          await this.getData(dataPath);
          return true;
        } catch (e) {
          if (e instanceof Errors_1.DataError) {
            return false;
          }
          throw e;
        }
      }
      /**
       * Returns the number of element which constitutes the array
       * @param dataPath
       * @returns {Promise<number>}
       * @throws {DataError}
       */
      async count(dataPath) {
        const result = await this.getData(dataPath);
        if (!Array.isArray(result)) {
          throw new Errors_1.DataError(`DataPath: ${dataPath} is not an array.`, 11);
        }
        const path = this.processDataPath(dataPath);
        const data = await this.retrieveData(path, false);
        return data.length;
      }
      /**
       * Returns the index of the object that meets the criteria submitted. Returns -1, if no match is found.
       * @param dataPath  base dataPath from where to start searching
       * @param searchValue value to look for in the dataPath
       * @param propertyName name of the property to look for searchValue
       * @returns {Promise<number>}
       */
      async getIndex(dataPath, searchValue, propertyName = "id") {
        const data = await this.getArrayData(dataPath);
        return data.map(function(element) {
          return element[propertyName];
        }).indexOf(searchValue);
      }
      /**
       * Return the index of the value inside the array. Returns -1, if no match is found.
       * @param dataPath  base dataPath from where to start searching
       * @param searchValue value to look for in the dataPath
       * @returns {Promise<number>}
       */
      async getIndexValue(dataPath, searchValue) {
        return (await this.getArrayData(dataPath)).indexOf(searchValue);
      }
      async getArrayData(dataPath) {
        const result = await this.getData(dataPath);
        if (!Array.isArray(result)) {
          throw new Errors_1.DataError(`DataPath: ${dataPath} is not an array.`, 11);
        }
        const path = this.processDataPath(dataPath);
        return this.retrieveData(path, false);
      }
      /**
       * Find all specific entry in an array/object
       * @param rootPath base dataPath from where to start searching
       * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.
       * @returns {Promise}
       * @throws {DataError}
       */
      async filter(rootPath, callback) {
        const result = await this.getData(rootPath);
        if (Array.isArray(result)) {
          return result.filter(callback);
        }
        if (result instanceof Object) {
          const entries = Object.entries(result);
          const found = entries.filter((entry) => {
            return callback(entry[1], entry[0]);
          });
          if (!found || found.length < 1) {
            return void 0;
          }
          return found.map((entry) => {
            return entry[1];
          });
        }
        throw new Errors_1.DataError("The entry at the path (" + rootPath + ") needs to be either an Object or an Array", 12);
      }
      /**
       * Find a specific entry in an array/object
       * @param rootPath base dataPath from where to start searching
       * @param callback method to filter the result and find the wanted entry. Receive the entry and it's index.
       * @returns {Promise}
       * @throws {DataError}
       */
      async find(rootPath, callback) {
        const result = await this.getData(rootPath);
        if (Array.isArray(result)) {
          return result.find(callback);
        }
        if (result instanceof Object) {
          const entries = Object.entries(result);
          const found = entries.find((entry) => {
            return callback(entry[1], entry[0]);
          });
          if (!found || found.length < 2) {
            return void 0;
          }
          return found[1];
        }
        throw new Errors_1.DataError("The entry at the path (" + rootPath + ") needs to be either an Object or an Array", 12);
      }
      /**
       * Pushing data into the database
       * @param dataPath path leading to the data
       * @param data data to push
       * @param override overriding or not the data, if not, it will merge them
       * @returns {Promise<void>}
       * @throws {DataError}
       */
      async push(dataPath, data, override = true) {
        return (0, Lock_1.writeLockAsync)(async () => {
          const dbData = await this.getParentData(dataPath, true);
          let toSet = data;
          if (!override) {
            if (Array.isArray(data)) {
              let storedData = dbData.getData();
              if (storedData === void 0) {
                storedData = [];
              } else if (!Array.isArray(storedData)) {
                throw new Errors_1.DataError("Can't merge another type of data with an Array", 3);
              }
              toSet = storedData.concat(data);
            } else if (data === Object(data)) {
              if (Array.isArray(dbData.getData())) {
                throw new Errors_1.DataError("Can't merge an Array with an Object", 4);
              }
              toSet = (0, Utils_1.merge)(dbData.getData(), data);
            }
          }
          dbData.setData(toSet);
          if (this.config.saveOnPush) {
            await this.save();
          }
        });
      }
      /**
       * Delete the data
       * @param dataPath path leading to the data
       */
      async delete(dataPath) {
        await (0, Lock_1.writeLockAsync)(async () => {
          const dbData = await this.getParentData(dataPath, true);
          dbData.delete();
          if (this.config.saveOnPush) {
            await this.save();
          }
        });
      }
      /**
       * Only use this if you know what you're doing.
       * It reset the full data of the database.
       * @param data
       */
      resetData(data) {
        this.data = data;
      }
      /**
       * Reload the database from the file
       */
      async reload() {
        this.loaded = false;
        await this.load();
      }
      /**
       * Manually load the database
       * It is automatically called when the first getData is done
       * @return {Promise<void>}
       * @throws {DatabaseError}
       */
      async load() {
        if (this.loaded) {
          return;
        }
        try {
          this.data = await this.config.adapter.readAsync();
          this.loaded = true;
        } catch (err) {
          throw new Errors_1.DatabaseError("Can't Load Database", 1, err);
        }
      }
      /**
       * Manually save the database
       * By default you can't save the database if it's not loaded
       * @param force force the save of the database
       * @return {Promise<void>}
       * @throws {DatabaseError}
       */
      async save(force) {
        force = force || false;
        if (!force && !this.loaded) {
          throw new Errors_1.DatabaseError("DataBase not loaded. Can't write", 7);
        }
        try {
          await this.config.adapter.writeAsync(this.data);
        } catch (err) {
          throw new Errors_1.DatabaseError("Can't save the database", 2, err);
        }
      }
      /**
       * Convert a router style path to a normal path
       * By default propertyName to search is "id"
       * @param path router based path to a correct base path
       * @param propertyName name of the property to look for searchValue
       */
      async fromPath(path, propertyName = "id") {
        const [, ...pathToQuery] = path.split("/");
        const pathObject = pathToQuery.reduce((prev, curr, indexPath) => {
          const isKey = indexPath % 2 === 0;
          if (isKey) {
            prev[`${curr}`] = "";
          } else {
            const keys = Object.keys(prev);
            prev[`${keys[keys.length - 1]}`] = `${curr}`;
          }
          return prev;
        }, {});
        let normalPath = [];
        for await (const pathKey of Object.keys(pathObject)) {
          normalPath.push(`/${pathKey}`);
          const pathValue = pathObject[pathKey];
          try {
            const pathIndex = await this.getIndex(normalPath.join(""), pathValue, propertyName);
            normalPath.push(`[${pathIndex}]`);
          } catch (error) {
            throw new Errors_1.DataError(`DataPath: ${normalPath.join("")}/${pathValue} not found.`, 13, error);
          }
        }
        return normalPath.join("");
      }
    };
    exports.JsonDB = JsonDB;
  }
});
export default require_JsonDB();
/*! Bundled license information:

rwlock/lib/lock.js:
  (*! ReadWriteLock - v5.0.0 - 2015-01-16
   * Author: Alberto La Rocca <a71104@gmail.com> (https://github.com/71104)
   * Released under the MIT license
   * Copyright (c) 2015 Alberto La Rocca *)
*/
//# sourceMappingURL=node-json-db.js.map
