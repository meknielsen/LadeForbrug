{
  "version": 3,
  "sources": ["browser-external:stream", "../../csv-parse/lib/index.js", "../../csv-parse/lib/utils/is_object.js", "../../csv-parse/lib/api/CsvError.js", "../../csv-parse/lib/api/normalize_columns_array.js", "../../csv-parse/lib/utils/ResizeableBuffer.js", "../../csv-parse/lib/api/init_state.js", "../../csv-parse/lib/utils/underscore.js", "../../csv-parse/lib/api/normalize_options.js", "../../csv-parse/lib/api/index.js"],
  "sourcesContent": ["module.exports = Object.create(new Proxy({}, {\n  get(_, key) {\n    if (\n      key !== '__esModule' &&\n      key !== '__proto__' &&\n      key !== 'constructor' &&\n      key !== 'splice'\n    ) {\n      console.warn(`Module \"stream\" has been externalized for browser compatibility. Cannot access \"stream.${key}\" in client code. See http://vitejs.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`)\n    }\n  }\n}))", "\n/*\nCSV Parse\n\nPlease look at the [project documentation](https://csv.js.org/parse/) for\nadditional information.\n*/\n\nimport { Transform } from 'stream';\nimport {is_object} from './utils/is_object.js';\nimport {transform} from './api/index.js';\nimport {CsvError} from './api/CsvError.js';\n\nclass Parser extends Transform {\n  constructor(opts = {}){\n    super({...{readableObjectMode: true}, ...opts, encoding: null});\n    this.api = transform(opts);\n    this.api.options.on_skip = (err, chunk) => {\n      this.emit('skip', err, chunk);\n    };\n    // Backward compatibility\n    this.state = this.api.state;\n    this.options = this.api.options;\n    this.info = this.api.info;\n  }\n  // Implementation of `Transform._transform`\n  _transform(buf, encoding, callback){\n    if(this.state.stop === true){\n      return;\n    }\n    const err = this.api.parse(buf, false, (record) => {\n      this.push(record);\n    }, () => {\n      this.push(null);\n      this.on('end', this.destroy);\n    });\n    if(err !== undefined){\n      this.state.stop = true;\n    }\n    callback(err);\n  }\n  // Implementation of `Transform._flush`\n  _flush(callback){\n    if(this.state.stop === true){\n      return;\n    }\n    const err = this.api.parse(undefined, true, (record) => {\n      this.push(record);\n    }, () => {\n      this.push(null);\n      this.on('end', this.destroy);\n    });\n    callback(err);\n  }\n}\n\nconst parse = function(){\n  let data, options, callback;\n  for(const i in arguments){\n    const argument = arguments[i];\n    const type = typeof argument;\n    if(data === undefined && (typeof argument === 'string' || Buffer.isBuffer(argument))){\n      data = argument;\n    }else if(options === undefined && is_object(argument)){\n      options = argument;\n    }else if(callback === undefined && type === 'function'){\n      callback = argument;\n    }else{\n      throw new CsvError('CSV_INVALID_ARGUMENT', [\n        'Invalid argument:',\n        `got ${JSON.stringify(argument)} at index ${i}`\n      ], options || {});\n    }\n  }\n  const parser = new Parser(options);\n  if(callback){\n    const records = options === undefined || options.objname === undefined ? [] : {};\n    parser.on('readable', function(){\n      let record;\n      while((record = this.read()) !== null){\n        if(options === undefined || options.objname === undefined){\n          records.push(record);\n        }else{\n          records[record[0]] = record[1];\n        }\n      }\n    });\n    parser.on('error', function(err){\n      callback(err, undefined, parser.api.__infoDataSet());\n    });\n    parser.on('end', function(){\n      callback(undefined, records, parser.api.__infoDataSet());\n    });\n  }\n  if(data !== undefined){\n    const writer = function(){\n      parser.write(data);\n      parser.end();\n    };\n    // Support Deno, Rollup doesnt provide a shim for setImmediate\n    if(typeof setImmediate === 'function'){\n      setImmediate(writer);\n    }else{\n      setTimeout(writer, 0);\n    }\n  }\n  return parser;\n};\n\n// export default parse\nexport { parse, Parser, CsvError };\n", "\nconst is_object = function(obj){\n  return (typeof obj === 'object' && obj !== null && !Array.isArray(obj));\n};\n\nexport {is_object};\n", "\nclass CsvError extends Error {\n  constructor(code, message, options, ...contexts) {\n    if(Array.isArray(message)) message = message.join(' ').trim();\n    super(message);\n    if(Error.captureStackTrace !== undefined){\n      Error.captureStackTrace(this, CsvError);\n    }\n    this.code = code;\n    for(const context of contexts){\n      for(const key in context){\n        const value = context[key];\n        this[key] = Buffer.isBuffer(value) ? value.toString(options.encoding) : value == null ? value : JSON.parse(JSON.stringify(value));\n      }\n    }\n  }\n}\n\nexport {CsvError};\n", "\nimport {CsvError} from './CsvError.js';\nimport {is_object} from '../utils/is_object.js';\n\nconst normalize_columns_array = function(columns){\n  const normalizedColumns = [];\n  for(let i = 0, l = columns.length; i < l; i++){\n    const column = columns[i];\n    if(column === undefined || column === null || column === false){\n      normalizedColumns[i] = { disabled: true };\n    }else if(typeof column === 'string'){\n      normalizedColumns[i] = { name: column };\n    }else if(is_object(column)){\n      if(typeof column.name !== 'string'){\n        throw new CsvError('CSV_OPTION_COLUMNS_MISSING_NAME', [\n          'Option columns missing name:',\n          `property \"name\" is required at position ${i}`,\n          'when column is an object literal'\n        ]);\n      }\n      normalizedColumns[i] = column;\n    }else{\n      throw new CsvError('CSV_INVALID_COLUMN_DEFINITION', [\n        'Invalid column definition:',\n        'expect a string or a literal object,',\n        `got ${JSON.stringify(column)} at position ${i}`\n      ]);\n    }\n  }\n  return normalizedColumns;\n};\n\nexport {normalize_columns_array};\n", "\nclass ResizeableBuffer{\n  constructor(size=100){\n    this.size = size;\n    this.length = 0;\n    this.buf = Buffer.allocUnsafe(size);\n  }\n  prepend(val){\n    if(Buffer.isBuffer(val)){\n      const length = this.length + val.length;\n      if(length >= this.size){\n        this.resize();\n        if(length >= this.size){\n          throw Error('INVALID_BUFFER_STATE');\n        }\n      }\n      const buf = this.buf;\n      this.buf = Buffer.allocUnsafe(this.size);\n      val.copy(this.buf, 0);\n      buf.copy(this.buf, val.length);\n      this.length += val.length;\n    }else{\n      const length = this.length++;\n      if(length === this.size){\n        this.resize();\n      }\n      const buf = this.clone();\n      this.buf[0] = val;\n      buf.copy(this.buf,1, 0, length);\n    }\n  }\n  append(val){\n    const length = this.length++;\n    if(length === this.size){\n      this.resize();\n    }\n    this.buf[length] = val;\n  }\n  clone(){\n    return Buffer.from(this.buf.slice(0, this.length));\n  }\n  resize(){\n    const length = this.length;\n    this.size = this.size * 2;\n    const buf = Buffer.allocUnsafe(this.size);\n    this.buf.copy(buf,0, 0, length);\n    this.buf = buf;\n  }\n  toString(encoding){\n    if(encoding){\n      return this.buf.slice(0, this.length).toString(encoding);\n    }else{\n      return Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));\n    }\n  }\n  toJSON(){\n    return this.toString('utf8');\n  }\n  reset(){\n    this.length = 0;\n  }\n}\n\nexport default ResizeableBuffer;\n", "\nimport ResizeableBuffer from '../utils/ResizeableBuffer.js';\n\n// white space characters\n// https://en.wikipedia.org/wiki/Whitespace_character\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions/Character_Classes#Types\n// \\f\\n\\r\\t\\v\\u00a0\\u1680\\u2000-\\u200a\\u2028\\u2029\\u202f\\u205f\\u3000\\ufeff\nconst np = 12;\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\nconst space = 32;\nconst tab = 9;\n\nconst init_state = function(options){\n  return {\n    bomSkipped: false,\n    bufBytesStart: 0,\n    castField: options.cast_function,\n    commenting: false,\n    // Current error encountered by a record\n    error: undefined,\n    enabled: options.from_line === 1,\n    escaping: false,\n    escapeIsQuote: Buffer.isBuffer(options.escape) && Buffer.isBuffer(options.quote) && Buffer.compare(options.escape, options.quote) === 0,\n    // columns can be `false`, `true`, `Array`\n    expectedRecordLength: Array.isArray(options.columns) ? options.columns.length : undefined,\n    field: new ResizeableBuffer(20),\n    firstLineToHeaders: options.cast_first_line_to_header,\n    needMoreDataSize: Math.max(\n      // Skip if the remaining buffer smaller than comment\n      options.comment !== null ? options.comment.length : 0,\n      // Skip if the remaining buffer can be delimiter\n      ...options.delimiter.map((delimiter) => delimiter.length),\n      // Skip if the remaining buffer can be escape sequence\n      options.quote !== null ? options.quote.length : 0,\n    ),\n    previousBuf: undefined,\n    quoting: false,\n    stop: false,\n    rawBuffer: new ResizeableBuffer(100),\n    record: [],\n    recordHasError: false,\n    record_length: 0,\n    recordDelimiterMaxLength: options.record_delimiter.length === 0 ? 0 : Math.max(...options.record_delimiter.map((v) => v.length)),\n    trimChars: [Buffer.from(' ', options.encoding)[0], Buffer.from('\\t', options.encoding)[0]],\n    wasQuoting: false,\n    wasRowDelimiter: false,\n    timchars: [\n      Buffer.from(Buffer.from([cr], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([nl], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([np], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([space], 'utf8').toString(), options.encoding),\n      Buffer.from(Buffer.from([tab], 'utf8').toString(), options.encoding),\n    ]\n  };\n};\n\nexport {init_state};\n", "\nconst underscore = function(str){\n  return str.replace(/([A-Z])/g, function(_, match){\n    return '_' + match.toLowerCase();\n  });\n};\n\nexport {underscore};\n", "\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {CsvError} from './CsvError.js';\nimport {underscore} from '../utils/underscore.js';\n\nconst normalize_options = function(opts){\n  const options = {};\n  // Merge with user options\n  for(const opt in opts){\n    options[underscore(opt)] = opts[opt];\n  }\n  // Normalize option `encoding`\n  // Note: defined first because other options depends on it\n  // to convert chars/strings into buffers.\n  if(options.encoding === undefined || options.encoding === true){\n    options.encoding = 'utf8';\n  }else if(options.encoding === null || options.encoding === false){\n    options.encoding = null;\n  }else if(typeof options.encoding !== 'string' && options.encoding !== null){\n    throw new CsvError('CSV_INVALID_OPTION_ENCODING', [\n      'Invalid option encoding:',\n      'encoding must be a string or null to return a buffer,',\n      `got ${JSON.stringify(options.encoding)}`\n    ], options);\n  }\n  // Normalize option `bom`\n  if(options.bom === undefined || options.bom === null || options.bom === false){\n    options.bom = false;\n  }else if(options.bom !== true){\n    throw new CsvError('CSV_INVALID_OPTION_BOM', [\n      'Invalid option bom:', 'bom must be true,',\n      `got ${JSON.stringify(options.bom)}`\n    ], options);\n  }\n  // Normalize option `cast`\n  options.cast_function = null;\n  if(options.cast === undefined || options.cast === null || options.cast === false || options.cast === ''){\n    options.cast = undefined;\n  }else if(typeof options.cast === 'function'){\n    options.cast_function = options.cast;\n    options.cast = true;\n  }else if(options.cast !== true){\n    throw new CsvError('CSV_INVALID_OPTION_CAST', [\n      'Invalid option cast:', 'cast must be true or a function,',\n      `got ${JSON.stringify(options.cast)}`\n    ], options);\n  }\n  // Normalize option `cast_date`\n  if(options.cast_date === undefined || options.cast_date === null || options.cast_date === false || options.cast_date === ''){\n    options.cast_date = false;\n  }else if(options.cast_date === true){\n    options.cast_date = function(value){\n      const date = Date.parse(value);\n      return !isNaN(date) ? new Date(date) : value;\n    };\n  }else if (typeof options.cast_date !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_CAST_DATE', [\n      'Invalid option cast_date:', 'cast_date must be true or a function,',\n      `got ${JSON.stringify(options.cast_date)}`\n    ], options);\n  }\n  // Normalize option `columns`\n  options.cast_first_line_to_header = null;\n  if(options.columns === true){\n    // Fields in the first line are converted as-is to columns\n    options.cast_first_line_to_header = undefined;\n  }else if(typeof options.columns === 'function'){\n    options.cast_first_line_to_header = options.columns;\n    options.columns = true;\n  }else if(Array.isArray(options.columns)){\n    options.columns = normalize_columns_array(options.columns);\n  }else if(options.columns === undefined || options.columns === null || options.columns === false){\n    options.columns = false;\n  }else{\n    throw new CsvError('CSV_INVALID_OPTION_COLUMNS', [\n      'Invalid option columns:',\n      'expect an array, a function or true,',\n      `got ${JSON.stringify(options.columns)}`\n    ], options);\n  }\n  // Normalize option `group_columns_by_name`\n  if(options.group_columns_by_name === undefined || options.group_columns_by_name === null || options.group_columns_by_name === false){\n    options.group_columns_by_name = false;\n  }else if(options.group_columns_by_name !== true){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'expect an boolean,',\n      `got ${JSON.stringify(options.group_columns_by_name)}`\n    ], options);\n  }else if(options.columns === false){\n    throw new CsvError('CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME', [\n      'Invalid option group_columns_by_name:',\n      'the `columns` mode must be activated.'\n    ], options);\n  }\n  // Normalize option `comment`\n  if(options.comment === undefined || options.comment === null || options.comment === false || options.comment === ''){\n    options.comment = null;\n  }else{\n    if(typeof options.comment === 'string'){\n      options.comment = Buffer.from(options.comment, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.comment)){\n      throw new CsvError('CSV_INVALID_OPTION_COMMENT', [\n        'Invalid option comment:',\n        'comment must be a buffer or a string,',\n        `got ${JSON.stringify(options.comment)}`\n      ], options);\n    }\n  }\n  // Normalize option `delimiter`\n  const delimiter_json = JSON.stringify(options.delimiter);\n  if(!Array.isArray(options.delimiter)) options.delimiter = [options.delimiter];\n  if(options.delimiter.length === 0){\n    throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n      'Invalid option delimiter:',\n      'delimiter must be a non empty string or buffer or array of string|buffer,',\n      `got ${delimiter_json}`\n    ], options);\n  }\n  options.delimiter = options.delimiter.map(function(delimiter){\n    if(delimiter === undefined || delimiter === null || delimiter === false){\n      return Buffer.from(',', options.encoding);\n    }\n    if(typeof delimiter === 'string'){\n      delimiter = Buffer.from(delimiter, options.encoding);\n    }\n    if(!Buffer.isBuffer(delimiter) || delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_DELIMITER', [\n        'Invalid option delimiter:',\n        'delimiter must be a non empty string or buffer or array of string|buffer,',\n        `got ${delimiter_json}`\n      ], options);\n    }\n    return delimiter;\n  });\n  // Normalize option `escape`\n  if(options.escape === undefined || options.escape === true){\n    options.escape = Buffer.from('\"', options.encoding);\n  }else if(typeof options.escape === 'string'){\n    options.escape = Buffer.from(options.escape, options.encoding);\n  }else if (options.escape === null || options.escape === false){\n    options.escape = null;\n  }\n  if(options.escape !== null){\n    if(!Buffer.isBuffer(options.escape)){\n      throw new Error(`Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(options.escape)}`);\n    }\n  }\n  // Normalize option `from`\n  if(options.from === undefined || options.from === null){\n    options.from = 1;\n  }else{\n    if(typeof options.from === 'string' && /\\d+/.test(options.from)){\n      options.from = parseInt(options.from);\n    }\n    if(Number.isInteger(options.from)){\n      if(options.from < 0){\n        throw new Error(`Invalid Option: from must be a positive integer, got ${JSON.stringify(opts.from)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from must be an integer, got ${JSON.stringify(options.from)}`);\n    }\n  }\n  // Normalize option `from_line`\n  if(options.from_line === undefined || options.from_line === null){\n    options.from_line = 1;\n  }else{\n    if(typeof options.from_line === 'string' && /\\d+/.test(options.from_line)){\n      options.from_line = parseInt(options.from_line);\n    }\n    if(Number.isInteger(options.from_line)){\n      if(options.from_line <= 0){\n        throw new Error(`Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(opts.from_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: from_line must be an integer, got ${JSON.stringify(opts.from_line)}`);\n    }\n  }\n  // Normalize options `ignore_last_delimiters`\n  if(options.ignore_last_delimiters === undefined || options.ignore_last_delimiters === null){\n    options.ignore_last_delimiters = false;\n  }else if(typeof options.ignore_last_delimiters === 'number'){\n    options.ignore_last_delimiters = Math.floor(options.ignore_last_delimiters);\n    if(options.ignore_last_delimiters === 0){\n      options.ignore_last_delimiters = false;\n    }\n  }else if(typeof options.ignore_last_delimiters !== 'boolean'){\n    throw new CsvError('CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS', [\n      'Invalid option `ignore_last_delimiters`:',\n      'the value must be a boolean value or an integer,',\n      `got ${JSON.stringify(options.ignore_last_delimiters)}`\n    ], options);\n  }\n  if(options.ignore_last_delimiters === true && options.columns === false){\n    throw new CsvError('CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS', [\n      'The option `ignore_last_delimiters`',\n      'requires the activation of the `columns` option'\n    ], options);\n  }\n  // Normalize option `info`\n  if(options.info === undefined || options.info === null || options.info === false){\n    options.info = false;\n  }else if(options.info !== true){\n    throw new Error(`Invalid Option: info must be true, got ${JSON.stringify(options.info)}`);\n  }\n  // Normalize option `max_record_size`\n  if(options.max_record_size === undefined || options.max_record_size === null || options.max_record_size === false){\n    options.max_record_size = 0;\n  }else if(Number.isInteger(options.max_record_size) && options.max_record_size >= 0){\n    // Great, nothing to do\n  }else if(typeof options.max_record_size === 'string' && /\\d+/.test(options.max_record_size)){\n    options.max_record_size = parseInt(options.max_record_size);\n  }else{\n    throw new Error(`Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(options.max_record_size)}`);\n  }\n  // Normalize option `objname`\n  if(options.objname === undefined || options.objname === null || options.objname === false){\n    options.objname = undefined;\n  }else if(Buffer.isBuffer(options.objname)){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty buffer`);\n    }\n    if(options.encoding === null){\n      // Don't call `toString`, leave objname as a buffer\n    }else{\n      options.objname = options.objname.toString(options.encoding);\n    }\n  }else if(typeof options.objname === 'string'){\n    if(options.objname.length === 0){\n      throw new Error(`Invalid Option: objname must be a non empty string`);\n    }\n    // Great, nothing to do\n  }else if(typeof options.objname === 'number'){\n    // if(options.objname.length === 0){\n    //   throw new Error(`Invalid Option: objname must be a non empty string`);\n    // }\n    // Great, nothing to do\n  }else{\n    throw new Error(`Invalid Option: objname must be a string or a buffer, got ${options.objname}`);\n  }\n  if(options.objname !== undefined){\n    if(typeof options.objname === 'number'){\n      if(options.columns !== false){\n        throw Error('Invalid Option: objname index cannot be combined with columns or be defined as a field');\n      }\n    }else{ // A string or a buffer\n      if(options.columns === false){\n        throw Error('Invalid Option: objname field must be combined with columns or be defined as an index');\n      }\n    }\n  }\n  // Normalize option `on_record`\n  if(options.on_record === undefined || options.on_record === null){\n    options.on_record = undefined;\n  }else if(typeof options.on_record !== 'function'){\n    throw new CsvError('CSV_INVALID_OPTION_ON_RECORD', [\n      'Invalid option `on_record`:',\n      'expect a function,',\n      `got ${JSON.stringify(options.on_record)}`\n    ], options);\n  }\n  // Normalize option `quote`\n  if(options.quote === null || options.quote === false || options.quote === ''){\n    options.quote = null;\n  }else{\n    if(options.quote === undefined || options.quote === true){\n      options.quote = Buffer.from('\"', options.encoding);\n    }else if(typeof options.quote === 'string'){\n      options.quote = Buffer.from(options.quote, options.encoding);\n    }\n    if(!Buffer.isBuffer(options.quote)){\n      throw new Error(`Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(options.quote)}`);\n    }\n  }\n  // Normalize option `raw`\n  if(options.raw === undefined || options.raw === null || options.raw === false){\n    options.raw = false;\n  }else if(options.raw !== true){\n    throw new Error(`Invalid Option: raw must be true, got ${JSON.stringify(options.raw)}`);\n  }\n  // Normalize option `record_delimiter`\n  if(options.record_delimiter === undefined){\n    options.record_delimiter = [];\n  }else if(typeof options.record_delimiter === 'string' || Buffer.isBuffer(options.record_delimiter)){\n    if(options.record_delimiter.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer,',\n        `got ${JSON.stringify(options.record_delimiter)}`\n      ], options);\n    }\n    options.record_delimiter = [options.record_delimiter];\n  }else if(!Array.isArray(options.record_delimiter)){\n    throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n      'Invalid option `record_delimiter`:',\n      'value must be a string, a buffer or array of string|buffer,',\n      `got ${JSON.stringify(options.record_delimiter)}`\n    ], options);\n  }\n  options.record_delimiter = options.record_delimiter.map(function(rd, i){\n    if(typeof rd !== 'string' && ! Buffer.isBuffer(rd)){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a string, a buffer or array of string|buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }else if(rd.length === 0){\n      throw new CsvError('CSV_INVALID_OPTION_RECORD_DELIMITER', [\n        'Invalid option `record_delimiter`:',\n        'value must be a non empty string or buffer',\n        `at index ${i},`,\n        `got ${JSON.stringify(rd)}`\n      ], options);\n    }\n    if(typeof rd === 'string'){\n      rd = Buffer.from(rd, options.encoding);\n    }\n    return rd;\n  });\n  // Normalize option `relax_column_count`\n  if(typeof options.relax_column_count === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count === undefined || options.relax_column_count === null){\n    options.relax_column_count = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(options.relax_column_count)}`);\n  }\n  if(typeof options.relax_column_count_less === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_less === undefined || options.relax_column_count_less === null){\n    options.relax_column_count_less = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(options.relax_column_count_less)}`);\n  }\n  if(typeof options.relax_column_count_more === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_column_count_more === undefined || options.relax_column_count_more === null){\n    options.relax_column_count_more = false;\n  }else{\n    throw new Error(`Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(options.relax_column_count_more)}`);\n  }\n  // Normalize option `relax_quotes`\n  if(typeof options.relax_quotes === 'boolean'){\n    // Great, nothing to do\n  }else if(options.relax_quotes === undefined || options.relax_quotes === null){\n    options.relax_quotes = false;\n  }else{\n    throw new Error(`Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(options.relax_quotes)}`);\n  }\n  // Normalize option `skip_empty_lines`\n  if(typeof options.skip_empty_lines === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_empty_lines === undefined || options.skip_empty_lines === null){\n    options.skip_empty_lines = false;\n  }else{\n    throw new Error(`Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(options.skip_empty_lines)}`);\n  }\n  // Normalize option `skip_records_with_empty_values`\n  if(typeof options.skip_records_with_empty_values === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_empty_values === undefined || options.skip_records_with_empty_values === null){\n    options.skip_records_with_empty_values = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(options.skip_records_with_empty_values)}`);\n  }\n  // Normalize option `skip_records_with_error`\n  if(typeof options.skip_records_with_error === 'boolean'){\n    // Great, nothing to do\n  }else if(options.skip_records_with_error === undefined || options.skip_records_with_error === null){\n    options.skip_records_with_error = false;\n  }else{\n    throw new Error(`Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(options.skip_records_with_error)}`);\n  }\n  // Normalize option `rtrim`\n  if(options.rtrim === undefined || options.rtrim === null || options.rtrim === false){\n    options.rtrim = false;\n  }else if(options.rtrim !== true){\n    throw new Error(`Invalid Option: rtrim must be a boolean, got ${JSON.stringify(options.rtrim)}`);\n  }\n  // Normalize option `ltrim`\n  if(options.ltrim === undefined || options.ltrim === null || options.ltrim === false){\n    options.ltrim = false;\n  }else if(options.ltrim !== true){\n    throw new Error(`Invalid Option: ltrim must be a boolean, got ${JSON.stringify(options.ltrim)}`);\n  }\n  // Normalize option `trim`\n  if(options.trim === undefined || options.trim === null || options.trim === false){\n    options.trim = false;\n  }else if(options.trim !== true){\n    throw new Error(`Invalid Option: trim must be a boolean, got ${JSON.stringify(options.trim)}`);\n  }\n  // Normalize options `trim`, `ltrim` and `rtrim`\n  if(options.trim === true && opts.ltrim !== false){\n    options.ltrim = true;\n  }else if(options.ltrim !== true){\n    options.ltrim = false;\n  }\n  if(options.trim === true && opts.rtrim !== false){\n    options.rtrim = true;\n  }else if(options.rtrim !== true){\n    options.rtrim = false;\n  }\n  // Normalize option `to`\n  if(options.to === undefined || options.to === null){\n    options.to = -1;\n  }else{\n    if(typeof options.to === 'string' && /\\d+/.test(options.to)){\n      options.to = parseInt(options.to);\n    }\n    if(Number.isInteger(options.to)){\n      if(options.to <= 0){\n        throw new Error(`Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(opts.to)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to must be an integer, got ${JSON.stringify(opts.to)}`);\n    }\n  }\n  // Normalize option `to_line`\n  if(options.to_line === undefined || options.to_line === null){\n    options.to_line = -1;\n  }else{\n    if(typeof options.to_line === 'string' && /\\d+/.test(options.to_line)){\n      options.to_line = parseInt(options.to_line);\n    }\n    if(Number.isInteger(options.to_line)){\n      if(options.to_line <= 0){\n        throw new Error(`Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(opts.to_line)}`);\n      }\n    }else{\n      throw new Error(`Invalid Option: to_line must be an integer, got ${JSON.stringify(opts.to_line)}`);\n    }\n  }\n  return options;\n};\n\nexport {normalize_options};\n", "\nimport {normalize_columns_array} from './normalize_columns_array.js';\nimport {init_state} from './init_state.js';\nimport {normalize_options} from './normalize_options.js';\nimport {CsvError} from './CsvError.js';\n\nconst isRecordEmpty = function(record){\n  return record.every((field) => field == null || field.toString && field.toString().trim() === '');\n};\n\nconst cr = 13; // `\\r`, carriage return, 0x0D in hexadécimal, 13 in decimal\nconst nl = 10; // `\\n`, newline, 0x0A in hexadecimal, 10 in decimal\n\nconst boms = {\n  // Note, the following are equals:\n  // Buffer.from(\"\\ufeff\")\n  // Buffer.from([239, 187, 191])\n  // Buffer.from('EFBBBF', 'hex')\n  'utf8': Buffer.from([239, 187, 191]),\n  // Note, the following are equals:\n  // Buffer.from \"\\ufeff\", 'utf16le\n  // Buffer.from([255, 254])\n  'utf16le': Buffer.from([255, 254])\n};\n\nconst transform = function(original_options = {}) {\n  const info = {\n    bytes: 0,\n    comment_lines: 0,\n    empty_lines: 0,\n    invalid_field_length: 0,\n    lines: 1,\n    records: 0\n  };\n  const options = normalize_options(original_options);\n  return {\n    info: info,\n    original_options: original_options,\n    options: options,\n    state: init_state(options),\n    __needMoreData: function(i, bufLen, end){\n      if(end) return false;\n      const {encoding, escape, quote} = this.options;\n      const {quoting, needMoreDataSize, recordDelimiterMaxLength} = this.state;\n      const numOfCharLeft = bufLen - i - 1;\n      const requiredLength = Math.max(\n        needMoreDataSize,\n        // Skip if the remaining buffer smaller than record delimiter\n        // If \"record_delimiter\" is yet to be discovered:\n        // 1. It is equals to `[]` and \"recordDelimiterMaxLength\" equals `0`\n        // 2. We set the length to windows line ending in the current encoding\n        // Note, that encoding is known from user or bom discovery at that point\n        // recordDelimiterMaxLength,\n        recordDelimiterMaxLength === 0 ? Buffer.from('\\r\\n', encoding).length : recordDelimiterMaxLength,\n        // Skip if remaining buffer can be an escaped quote\n        quoting ? ((escape === null ? 0 : escape.length) + quote.length) : 0,\n        // Skip if remaining buffer can be record delimiter following the closing quote\n        quoting ? (quote.length + recordDelimiterMaxLength) : 0,\n      );\n      return numOfCharLeft < requiredLength;\n    },\n    // Central parser implementation\n    parse: function(nextBuf, end, push, close){\n      const {bom, encoding, from_line, ltrim, max_record_size,raw, relax_quotes, rtrim, skip_empty_lines, to, to_line} = this.options;\n      let {comment, escape, quote, record_delimiter} = this.options;\n      const {bomSkipped, previousBuf, rawBuffer, escapeIsQuote} = this.state;\n      let buf;\n      if(previousBuf === undefined){\n        if(nextBuf === undefined){\n          // Handle empty string\n          close();\n          return;\n        }else{\n          buf = nextBuf;\n        }\n      }else if(previousBuf !== undefined && nextBuf === undefined){\n        buf = previousBuf;\n      }else{\n        buf = Buffer.concat([previousBuf, nextBuf]);\n      }\n      // Handle UTF BOM\n      if(bomSkipped === false){\n        if(bom === false){\n          this.state.bomSkipped = true;\n        }else if(buf.length < 3){\n          // No enough data\n          if(end === false){\n            // Wait for more data\n            this.state.previousBuf = buf;\n            return;\n          }\n        }else{\n          for(const encoding in boms){\n            if(boms[encoding].compare(buf, 0, boms[encoding].length) === 0){\n              // Skip BOM\n              const bomLength = boms[encoding].length;\n              this.state.bufBytesStart += bomLength;\n              buf = buf.slice(bomLength);\n              // Renormalize original options with the new encoding\n              this.options = normalize_options({...this.original_options, encoding: encoding});\n              // Options will re-evaluate the Buffer with the new encoding\n              ({comment, escape, quote } = this.options);\n              break;\n            }\n          }\n          this.state.bomSkipped = true;\n        }\n      }\n      const bufLen = buf.length;\n      let pos;\n      for(pos = 0; pos < bufLen; pos++){\n        // Ensure we get enough space to look ahead\n        // There should be a way to move this out of the loop\n        if(this.__needMoreData(pos, bufLen, end)){\n          break;\n        }\n        if(this.state.wasRowDelimiter === true){\n          this.info.lines++;\n          this.state.wasRowDelimiter = false;\n        }\n        if(to_line !== -1 && this.info.lines > to_line){\n          this.state.stop = true;\n          close();\n          return;\n        }\n        // Auto discovery of record_delimiter, unix, mac and windows supported\n        if(this.state.quoting === false && record_delimiter.length === 0){\n          const record_delimiterCount = this.__autoDiscoverRecordDelimiter(buf, pos);\n          if(record_delimiterCount){\n            record_delimiter = this.options.record_delimiter;\n          }\n        }\n        const chr = buf[pos];\n        if(raw === true){\n          rawBuffer.append(chr);\n        }\n        if((chr === cr || chr === nl) && this.state.wasRowDelimiter === false){\n          this.state.wasRowDelimiter = true;\n        }\n        // Previous char was a valid escape char\n        // treat the current char as a regular char\n        if(this.state.escaping === true){\n          this.state.escaping = false;\n        }else{\n          // Escape is only active inside quoted fields\n          // We are quoting, the char is an escape chr and there is a chr to escape\n          // if(escape !== null && this.state.quoting === true && chr === escape && pos + 1 < bufLen){\n          if(escape !== null && this.state.quoting === true && this.__isEscape(buf, pos, chr) && pos + escape.length < bufLen){\n            if(escapeIsQuote){\n              if(this.__isQuote(buf, pos+escape.length)){\n                this.state.escaping = true;\n                pos += escape.length - 1;\n                continue;\n              }\n            }else{\n              this.state.escaping = true;\n              pos += escape.length - 1;\n              continue;\n            }\n          }\n          // Not currently escaping and chr is a quote\n          // TODO: need to compare bytes instead of single char\n          if(this.state.commenting === false && this.__isQuote(buf, pos)){\n            if(this.state.quoting === true){\n              const nextChr = buf[pos+quote.length];\n              const isNextChrTrimable = rtrim && this.__isCharTrimable(buf, pos+quote.length);\n              const isNextChrComment = comment !== null && this.__compareBytes(comment, buf, pos+quote.length, nextChr);\n              const isNextChrDelimiter = this.__isDelimiter(buf, pos+quote.length, nextChr);\n              const isNextChrRecordDelimiter = record_delimiter.length === 0 ? this.__autoDiscoverRecordDelimiter(buf, pos+quote.length) : this.__isRecordDelimiter(nextChr, buf, pos+quote.length);\n              // Escape a quote\n              // Treat next char as a regular character\n              if(escape !== null && this.__isEscape(buf, pos, chr) && this.__isQuote(buf, pos + escape.length)){\n                pos += escape.length - 1;\n              }else if(!nextChr || isNextChrDelimiter || isNextChrRecordDelimiter || isNextChrComment || isNextChrTrimable){\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                pos += quote.length - 1;\n                continue;\n              }else if(relax_quotes === false){\n                const err = this.__error(\n                  new CsvError('CSV_INVALID_CLOSING_QUOTE', [\n                    'Invalid Closing Quote:',\n                    `got \"${String.fromCharCode(nextChr)}\"`,\n                    `at line ${this.info.lines}`,\n                    'instead of delimiter, record delimiter, trimable character',\n                    '(if activated) or comment',\n                  ], this.options, this.__infoField())\n                );\n                if(err !== undefined) return err;\n              }else{\n                this.state.quoting = false;\n                this.state.wasQuoting = true;\n                this.state.field.prepend(quote);\n                pos += quote.length - 1;\n              }\n            }else{\n              if(this.state.field.length !== 0){\n                // In relax_quotes mode, treat opening quote preceded by chrs as regular\n                if(relax_quotes === false){\n                  const info = this.__infoField();\n                  const bom = Object.keys(boms).map(b => boms[b].equals(this.state.field.toString()) ? b : false).filter(Boolean)[0];\n                  const err = this.__error(\n                    new CsvError('INVALID_OPENING_QUOTE', [\n                      'Invalid Opening Quote:',\n                      `a quote is found on field ${JSON.stringify(info.column)} at line ${info.lines}, value is ${JSON.stringify(this.state.field.toString(encoding))}`,\n                      bom ? `(${bom} bom)` : undefined\n                    ], this.options, info, {\n                      field: this.state.field,\n                    })\n                  );\n                  if(err !== undefined) return err;\n                }\n              }else{\n                this.state.quoting = true;\n                pos += quote.length - 1;\n                continue;\n              }\n            }\n          }\n          if(this.state.quoting === false){\n            const recordDelimiterLength = this.__isRecordDelimiter(chr, buf, pos);\n            if(recordDelimiterLength !== 0){\n              // Do not emit comments which take a full line\n              const skipCommentLine = this.state.commenting && (this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0);\n              if(skipCommentLine){\n                this.info.comment_lines++;\n                // Skip full comment line\n              }else{\n                // Activate records emition if above from_line\n                if(this.state.enabled === false && this.info.lines + (this.state.wasRowDelimiter === true ? 1: 0) >= from_line){\n                  this.state.enabled = true;\n                  this.__resetField();\n                  this.__resetRecord();\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                // Skip if line is empty and skip_empty_lines activated\n                if(skip_empty_lines === true && this.state.wasQuoting === false && this.state.record.length === 0 && this.state.field.length === 0){\n                  this.info.empty_lines++;\n                  pos += recordDelimiterLength - 1;\n                  continue;\n                }\n                this.info.bytes = this.state.bufBytesStart + pos;\n                const errField = this.__onField();\n                if(errField !== undefined) return errField;\n                this.info.bytes = this.state.bufBytesStart + pos + recordDelimiterLength;\n                const errRecord = this.__onRecord(push);\n                if(errRecord !== undefined) return errRecord;\n                if(to !== -1 && this.info.records >= to){\n                  this.state.stop = true;\n                  close();\n                  return;\n                }\n              }\n              this.state.commenting = false;\n              pos += recordDelimiterLength - 1;\n              continue;\n            }\n            if(this.state.commenting){\n              continue;\n            }\n            const commentCount = comment === null ? 0 : this.__compareBytes(comment, buf, pos, chr);\n            if(commentCount !== 0){\n              this.state.commenting = true;\n              continue;\n            }\n            const delimiterLength = this.__isDelimiter(buf, pos, chr);\n            if(delimiterLength !== 0){\n              this.info.bytes = this.state.bufBytesStart + pos;\n              const errField = this.__onField();\n              if(errField !== undefined) return errField;\n              pos += delimiterLength - 1;\n              continue;\n            }\n          }\n        }\n        if(this.state.commenting === false){\n          if(max_record_size !== 0 && this.state.record_length + this.state.field.length > max_record_size){\n            return this.__error(\n              new CsvError('CSV_MAX_RECORD_SIZE', [\n                'Max Record Size:',\n                'record exceed the maximum number of tolerated bytes',\n                `of ${max_record_size}`,\n                `at line ${this.info.lines}`,\n              ], this.options, this.__infoField())\n            );\n          }\n        }\n        const lappend = ltrim === false || this.state.quoting === true || this.state.field.length !== 0 || !this.__isCharTrimable(buf, pos);\n        // rtrim in non quoting is handle in __onField\n        const rappend = rtrim === false || this.state.wasQuoting === false;\n        if(lappend === true && rappend === true){\n          this.state.field.append(chr);\n        }else if(rtrim === true && !this.__isCharTrimable(buf, pos)){\n          return this.__error(\n            new CsvError('CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE', [\n              'Invalid Closing Quote:',\n              'found non trimable byte after quote',\n              `at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n        }else{\n          if(lappend === false){\n            pos += this.__isCharTrimable(buf, pos) - 1;\n          }\n          continue;\n        }\n      }\n      if(end === true){\n        // Ensure we are not ending in a quoting state\n        if(this.state.quoting === true){\n          const err = this.__error(\n            new CsvError('CSV_QUOTE_NOT_CLOSED', [\n              'Quote Not Closed:',\n              `the parsing is finished with an opening quote at line ${this.info.lines}`,\n            ], this.options, this.__infoField())\n          );\n          if(err !== undefined) return err;\n        }else{\n          // Skip last line if it has no characters\n          if(this.state.wasQuoting === true || this.state.record.length !== 0 || this.state.field.length !== 0){\n            this.info.bytes = this.state.bufBytesStart + pos;\n            const errField = this.__onField();\n            if(errField !== undefined) return errField;\n            const errRecord = this.__onRecord(push);\n            if(errRecord !== undefined) return errRecord;\n          }else if(this.state.wasRowDelimiter === true){\n            this.info.empty_lines++;\n          }else if(this.state.commenting === true){\n            this.info.comment_lines++;\n          }\n        }\n      }else{\n        this.state.bufBytesStart += pos;\n        this.state.previousBuf = buf.slice(pos);\n      }\n      if(this.state.wasRowDelimiter === true){\n        this.info.lines++;\n        this.state.wasRowDelimiter = false;\n      }\n    },\n    __onRecord: function(push){\n      const {columns, group_columns_by_name, encoding, info, from, relax_column_count, relax_column_count_less, relax_column_count_more, raw, skip_records_with_empty_values} = this.options;\n      const {enabled, record} = this.state;\n      if(enabled === false){\n        return this.__resetRecord();\n      }\n      // Convert the first line into column names\n      const recordLength = record.length;\n      if(columns === true){\n        if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n          this.__resetRecord();\n          return;\n        }\n        return this.__firstLineToColumns(record);\n      }\n      if(columns === false && this.info.records === 0){\n        this.state.expectedRecordLength = recordLength;\n      }\n      if(recordLength !== this.state.expectedRecordLength){\n        const err = columns === false ?\n          new CsvError('CSV_RECORD_INCONSISTENT_FIELDS_LENGTH', [\n            'Invalid Record Length:',\n            `expect ${this.state.expectedRecordLength},`,\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          })\n          :\n          new CsvError('CSV_RECORD_INCONSISTENT_COLUMNS', [\n            'Invalid Record Length:',\n            `columns length is ${columns.length},`, // rename columns\n            `got ${recordLength} on line ${this.info.lines}`,\n          ], this.options, this.__infoField(), {\n            record: record,\n          });\n        if(relax_column_count === true ||\n          (relax_column_count_less === true && recordLength < this.state.expectedRecordLength) ||\n          (relax_column_count_more === true && recordLength > this.state.expectedRecordLength)){\n          this.info.invalid_field_length++;\n          this.state.error = err;\n        // Error is undefined with skip_records_with_error\n        }else{\n          const finalErr = this.__error(err);\n          if(finalErr) return finalErr;\n        }\n      }\n      if(skip_records_with_empty_values === true && isRecordEmpty(record)){\n        this.__resetRecord();\n        return;\n      }\n      if(this.state.recordHasError === true){\n        this.__resetRecord();\n        this.state.recordHasError = false;\n        return;\n      }\n      this.info.records++;\n      if(from === 1 || this.info.records >= from){\n        const {objname} = this.options;\n        // With columns, records are object\n        if(columns !== false){\n          const obj = {};\n          // Transform record array to an object\n          for(let i = 0, l = record.length; i < l; i++){\n            if(columns[i] === undefined || columns[i].disabled) continue;\n            // Turn duplicate columns into an array\n            if (group_columns_by_name === true && obj[columns[i].name] !== undefined) {\n              if (Array.isArray(obj[columns[i].name])) {\n                obj[columns[i].name] = obj[columns[i].name].concat(record[i]);\n              } else {\n                obj[columns[i].name] = [obj[columns[i].name], record[i]];\n              }\n            } else {\n              obj[columns[i].name] = record[i];\n            }\n          }\n          // Without objname (default)\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: obj},\n              (raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {}),\n              (info === true ? {info: this.__infoRecord()}: {})\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [obj[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? obj : [obj[objname], obj]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        // Without columns, records are array\n        }else{\n          if(raw === true || info === true){\n            const extRecord = Object.assign(\n              {record: record},\n              raw === true ? {raw: this.state.rawBuffer.toString(encoding)}: {},\n              info === true ? {info: this.__infoRecord()}: {}\n            );\n            const err = this.__push(\n              objname === undefined ? extRecord : [record[objname], extRecord]\n              , push);\n            if(err){\n              return err;\n            }\n          }else{\n            const err = this.__push(\n              objname === undefined ? record : [record[objname], record]\n              , push);\n            if(err){\n              return err;\n            }\n          }\n        }\n      }\n      this.__resetRecord();\n    },\n    __firstLineToColumns: function(record){\n      const {firstLineToHeaders} = this.state;\n      try{\n        const headers = firstLineToHeaders === undefined ? record : firstLineToHeaders.call(null, record);\n        if(!Array.isArray(headers)){\n          return this.__error(\n            new CsvError('CSV_INVALID_COLUMN_MAPPING', [\n              'Invalid Column Mapping:',\n              'expect an array from column function,',\n              `got ${JSON.stringify(headers)}`\n            ], this.options, this.__infoField(), {\n              headers: headers,\n            })\n          );\n        }\n        const normalizedHeaders = normalize_columns_array(headers);\n        this.state.expectedRecordLength = normalizedHeaders.length;\n        this.options.columns = normalizedHeaders;\n        this.__resetRecord();\n        return;\n      }catch(err){\n        return err;\n      }\n    },\n    __resetRecord: function(){\n      if(this.options.raw === true){\n        this.state.rawBuffer.reset();\n      }\n      this.state.error = undefined;\n      this.state.record = [];\n      this.state.record_length = 0;\n    },\n    __onField: function(){\n      const {cast, encoding, rtrim, max_record_size} = this.options;\n      const {enabled, wasQuoting} = this.state;\n      // Short circuit for the from_line options\n      if(enabled === false){\n        return this.__resetField();\n      }\n      let field = this.state.field.toString(encoding);\n      if(rtrim === true && wasQuoting === false){\n        field = field.trimRight();\n      }\n      if(cast === true){\n        const [err, f] = this.__cast(field);\n        if(err !== undefined) return err;\n        field = f;\n      }\n      this.state.record.push(field);\n      // Increment record length if record size must not exceed a limit\n      if(max_record_size !== 0 && typeof field === 'string'){\n        this.state.record_length += field.length;\n      }\n      this.__resetField();\n    },\n    __resetField: function(){\n      this.state.field.reset();\n      this.state.wasQuoting = false;\n    },\n    __push: function(record, push){\n      const {on_record} = this.options;\n      if(on_record !== undefined){\n        const info = this.__infoRecord();\n        try{\n          record = on_record.call(null, record, info);\n        }catch(err){\n          return err;\n        }\n        if(record === undefined || record === null){ return; }\n      }\n      push(record);\n    },\n    // Return a tuple with the error and the casted value\n    __cast: function(field){\n      const {columns, relax_column_count} = this.options;\n      const isColumns = Array.isArray(columns);\n      // Dont loose time calling cast\n      // because the final record is an object\n      // and this field can't be associated to a key present in columns\n      if(isColumns === true && relax_column_count && this.options.columns.length <= this.state.record.length){\n        return [undefined, undefined];\n      }\n      if(this.state.castField !== null){\n        try{\n          const info = this.__infoField();\n          return [undefined, this.state.castField.call(null, field, info)];\n        }catch(err){\n          return [err];\n        }\n      }\n      if(this.__isFloat(field)){\n        return [undefined, parseFloat(field)];\n      }else if(this.options.cast_date !== false){\n        const info = this.__infoField();\n        return [undefined, this.options.cast_date.call(null, field, info)];\n      }\n      return [undefined, field];\n    },\n    // Helper to test if a character is a space or a line delimiter\n    __isCharTrimable: function(buf, pos){\n      const isTrim = (buf, pos) => {\n        const {timchars} = this.state;\n        loop1: for(let i = 0; i < timchars.length; i++){\n          const timchar = timchars[i];\n          for(let j = 0; j < timchar.length; j++){\n            if(timchar[j] !== buf[pos+j]) continue loop1;\n          }\n          return timchar.length;\n        }\n        return 0;\n      };\n      return isTrim(buf, pos);\n    },\n    // Keep it in case we implement the `cast_int` option\n    // __isInt(value){\n    //   // return Number.isInteger(parseInt(value))\n    //   // return !isNaN( parseInt( obj ) );\n    //   return /^(\\-|\\+)?[1-9][0-9]*$/.test(value)\n    // }\n    __isFloat: function(value){\n      return (value - parseFloat(value) + 1) >= 0; // Borrowed from jquery\n    },\n    __compareBytes: function(sourceBuf, targetBuf, targetPos, firstByte){\n      if(sourceBuf[0] !== firstByte) return 0;\n      const sourceLength = sourceBuf.length;\n      for(let i = 1; i < sourceLength; i++){\n        if(sourceBuf[i] !== targetBuf[targetPos+i]) return 0;\n      }\n      return sourceLength;\n    },\n    __isDelimiter: function(buf, pos, chr){\n      const {delimiter, ignore_last_delimiters} = this.options;\n      if(ignore_last_delimiters === true && this.state.record.length === this.options.columns.length - 1){\n        return 0;\n      }else if(ignore_last_delimiters !== false && typeof ignore_last_delimiters === 'number' && this.state.record.length === ignore_last_delimiters - 1){\n        return 0;\n      }\n      loop1: for(let i = 0; i < delimiter.length; i++){\n        const del = delimiter[i];\n        if(del[0] === chr){\n          for(let j = 1; j < del.length; j++){\n            if(del[j] !== buf[pos+j]) continue loop1;\n          }\n          return del.length;\n        }\n      }\n      return 0;\n    },\n    __isRecordDelimiter: function(chr, buf, pos){\n      const {record_delimiter} = this.options;\n      const recordDelimiterLength = record_delimiter.length;\n      loop1: for(let i = 0; i < recordDelimiterLength; i++){\n        const rd = record_delimiter[i];\n        const rdLength = rd.length;\n        if(rd[0] !== chr){\n          continue;\n        }\n        for(let j = 1; j < rdLength; j++){\n          if(rd[j] !== buf[pos+j]){\n            continue loop1;\n          }\n        }\n        return rd.length;\n      }\n      return 0;\n    },\n    __isEscape: function(buf, pos, chr){\n      const {escape} = this.options;\n      if(escape === null) return false;\n      const l = escape.length;\n      if(escape[0] === chr){\n        for(let i = 0; i < l; i++){\n          if(escape[i] !== buf[pos+i]){\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    },\n    __isQuote: function(buf, pos){\n      const {quote} = this.options;\n      if(quote === null) return false;\n      const l = quote.length;\n      for(let i = 0; i < l; i++){\n        if(quote[i] !== buf[pos+i]){\n          return false;\n        }\n      }\n      return true;\n    },\n    __autoDiscoverRecordDelimiter: function(buf, pos){\n      const { encoding } = this.options;\n      // Note, we don't need to cache this information in state,\n      // It is only called on the first line until we find out a suitable\n      // record delimiter.\n      const rds = [\n        // Important, the windows line ending must be before mac os 9\n        Buffer.from('\\r\\n', encoding),\n        Buffer.from('\\n', encoding),\n        Buffer.from('\\r', encoding),\n      ];\n      loop: for(let i = 0; i < rds.length; i++){\n        const l = rds[i].length;\n        for(let j = 0; j < l; j++){\n          if(rds[i][j] !== buf[pos + j]){\n            continue loop;\n          }\n        }\n        this.options.record_delimiter.push(rds[i]);\n        this.state.recordDelimiterMaxLength = rds[i].length;\n        return rds[i].length;\n      }\n      return 0;\n    },\n    __error: function(msg){\n      const {encoding, raw, skip_records_with_error} = this.options;\n      const err = typeof msg === 'string' ? new Error(msg) : msg;\n      if(skip_records_with_error){\n        this.state.recordHasError = true;\n        if(this.options.on_skip !== undefined){\n          this.options.on_skip(err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        }\n        // this.emit('skip', err, raw ? this.state.rawBuffer.toString(encoding) : undefined);\n        return undefined;\n      }else{\n        return err;\n      }\n    },\n    __infoDataSet: function(){\n      return {\n        ...this.info,\n        columns: this.options.columns\n      };\n    },\n    __infoRecord: function(){\n      const {columns, raw, encoding} = this.options;\n      return {\n        ...this.__infoDataSet(),\n        error: this.state.error,\n        header: columns === true,\n        index: this.state.record.length,\n        raw: raw ? this.state.rawBuffer.toString(encoding) : undefined\n      };\n    },\n    __infoField: function(){\n      const {columns} = this.options;\n      const isColumns = Array.isArray(columns);\n      return {\n        ...this.__infoRecord(),\n        column: isColumns === true ?\n          (columns.length > this.state.record.length ?\n            columns[this.state.record.length].name :\n            null\n          ) :\n          this.state.record.length,\n        quoting: this.state.wasQuoting,\n      };\n    }\n  };\n};\n\n\nexport {transform, CsvError};\n"],
  "mappings": "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",
  "names": ["cr", "nl", "encoding", "info", "bom", "buf", "pos"]
}
